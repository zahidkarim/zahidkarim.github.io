<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2015-09-14T14:37:00-07:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Null Is Something</title>
    <link rel="alternate" href="http://blog.url.com/2015/09/14/null_is_something/"/>
    <id>http://blog.url.com/2015/09/14/null_is_something/</id>
    <published>2015-09-14T14:37:00-07:00</published>
    <updated>2015-09-14T14:38:09-07:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;Learnings From: &lt;strong&gt;RailsConf 2015 - Nothing is Something&lt;/strong&gt;&lt;/h2&gt;

&lt;h3&gt;Info&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;The talk can be viewed &lt;a href="https://www.youtube.com/watch?t=126&amp;amp;v=29MAL8pJImQ"&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Speaker: Sandy Metz&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Themes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Introspective into &lt;code&gt;if&lt;/code&gt; statements&lt;/li&gt;
&lt;li&gt;Condition Adverse | Message Centric  Abstract Seeking&lt;/li&gt;
&lt;li&gt;Inheritance and Composition&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Introspective into &lt;code&gt;if&lt;/code&gt; statements&lt;/h4&gt;

&lt;p&gt;The take away from this section is to understand Ruby&amp;rsquo;s &lt;code&gt;if&lt;/code&gt; statement essentially evaluates true and false and then acts accordingly.&lt;/p&gt;

&lt;p&gt;But if statements can be enablers. Here&amp;rsquo;s how:&lt;/p&gt;

&lt;p&gt;Say we have an &lt;code&gt;Book&lt;/code&gt; class and the book class has a &lt;code&gt;find&lt;/code&gt; method.
&amp;ldquo;`
Book.find(&amp;quot;to kill a mockingbird&amp;rdquo;)
    =&amp;gt; &amp;lt;#Book:03939&amp;hellip;&lt;/p&gt;

&lt;p&gt;Book.find(&amp;ldquo;&amp;rdquo;)
    =&amp;gt; nil
&lt;code&gt;
When we call `find()` we get a `Book` object back but when we call `find()` on and empty string we get `nil`. So say we want to iterate over a collection of `Books`
&lt;/code&gt;
titles = [&amp;ldquo;To Kill a Mocking Bird&amp;rdquo;, &amp;ldquo;&amp;rdquo;, &amp;ldquo;The Gambler&amp;rdquo;]
all&lt;em&gt;books = titles.each { |t| Book.find(t) }
    =&amp;gt; [&amp;lt;#Book:8932&amp;gt;, nil, &amp;lt;#Book:7823&amp;gt;]
all&lt;/em&gt;books.each { |book| book.title }
    =&amp;gt; &amp;ldquo;To Kill a MockingBird&amp;rdquo;
    =&amp;gt; ###Error Occurs Here
&lt;code&gt;
This gets us thinking that `nil` went from being nothing to being something. Before we were fine with nil being in our code but now we are sending something to a `Null Object` we need to consider how to deal with it. We could use some built in methods like `compact(), send(), try()` or we could use abstraction and create a `MissingBook` Class that can return an object which can support a `title` method. Both the `Book` and `Missing Boo` classes can then be called to collect all Books:
&lt;/code&gt;
titles = [&amp;ldquo;To Kill a Mocking Bird&amp;rdquo;, &amp;ldquo;&amp;rdquo;, &amp;ldquo;The Gambler&amp;rdquo;]
all&lt;em&gt;books = titles.each { |t| Book.find(t) || MissingBook(t) }
    =&amp;gt; [&amp;lt;#Book:8932&amp;gt;, &amp;lt;#MissingBook:8432&amp;gt;, &amp;lt;#Book:7823&amp;gt;]
all&lt;/em&gt;books.each { |book| book.title }
    =&amp;gt; &amp;ldquo;To Kill a MockingBird&amp;rdquo;
    =&amp;gt; &amp;ldquo;Missing Book&amp;rdquo;
    =&amp;gt; &amp;ldquo;The Gambler&amp;rdquo;
&amp;ldquo;&lt;code&gt;
**Note:** this is a key concept here. Understanding&lt;/code&gt;nil` has a major role in how we develop code.&lt;/p&gt;

&lt;h4&gt;Condition Adverse | Message Centric  Abstract Seeking&lt;/h4&gt;

&lt;p&gt;The next key concept Sandy Metz brings up is the thought that we should approach conditionals adversely and think of objects as things we send messages to, &lt;strong&gt;Message Centric&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Lets say we have a &lt;code&gt;Playlist&lt;/code&gt; class:
&amp;rdquo;`
class Playlist
    def songs
        [&amp;ldquo;Song 1&amp;rdquo;, &amp;ldquo;Song 2&amp;rdquo;, &amp;ldquo;Song 3&amp;rdquo;]
    end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def list
    songs.each { |song| puts &amp;quot;#{song} \n&amp;quot; }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;Playlist.new.list
    =&amp;gt; &amp;ldquo;Song 1&amp;rdquo;
    =&amp;gt; &amp;ldquo;Song 2&amp;rdquo;
    =&amp;gt; &amp;ldquo;Song 3&amp;rdquo;
&lt;code&gt;
Now say we need a `RandomPlaylist`:
Here we can use inheritance here to solve our issue
&lt;/code&gt;
class RandomPlaylist &amp;lt; Playlist
    def songs
        super.shuffle
    end
end&lt;/p&gt;

&lt;p&gt;RandomPlaylist.new.list
    =&amp;gt; &amp;ldquo;Song 2&amp;rdquo;
    =&amp;gt; &amp;ldquo;Song 3&amp;rdquo;
    =&amp;gt; &amp;ldquo;Song 1&amp;rdquo;
&lt;code&gt;
Now if we want to add a `DuplicatePlaylist` where all the songs appear twice we can also use inheritance:
&lt;/code&gt;
class DuplicatePlaylist &amp;lt; Playlist
    def songs
        duplicate = super.dup
        super.push(duplicate).flatten
    end
end&lt;/p&gt;

&lt;p&gt;DuplicatePlaylist.new.list
    =&amp;gt; &amp;ldquo;Song 1&amp;rdquo;
    =&amp;gt; &amp;ldquo;Song 2&amp;rdquo;
    =&amp;gt; &amp;ldquo;Song 3&amp;rdquo;
    =&amp;gt; &amp;ldquo;Song 1&amp;rdquo;
    =&amp;gt; &amp;ldquo;Song 2&amp;rdquo;
    =&amp;gt; &amp;ldquo;Song 3&amp;rdquo;
&lt;code&gt;
Here is where things get hairy. What if we wanted a `DuplicatedRandomPlaylist`. Here is where inheritance gets dicey and we need to move to composition.
&lt;/code&gt;
class Playlist
    SONGS = [&amp;ldquo;Song 1&amp;rdquo;, &amp;ldquo;Song 2&amp;rdquo;, &amp;ldquo;Song 3&amp;rdquo;]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def initialize(length:, type:)
    @songs = length.set_length(SONGS)
    @formatted = type.organize(@songs)
end

def list
    @formatted.each { |song| puts &amp;quot;#{song} \n&amp;quot; }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;class DoubleLength
    def set_length(songs)
        duplicate = songs.dup
        songs.push(duplicate).flatten
    end
end&lt;/p&gt;

&lt;p&gt;class DefaultLength
    def set_length(songs)
        songs
    end
end&lt;/p&gt;

&lt;p&gt;class RandomList
    def organize(songs)
        songs.shuffle
    end
end&lt;/p&gt;

&lt;p&gt;class DefaultList
    def organize(songs)
        songs
    end
end&lt;/p&gt;

&lt;p&gt;Playlist.new(DoubleLnegth.new,RandomList.new).list
 =&amp;gt; Song 1
    Song 2
    Song 2
    Song 1
    Song 3
    Song 3&lt;/p&gt;

&lt;p&gt;Playlist.new(DefaultLength.new,RandomList.new).list
=&amp;gt;  Song 3
    Song 2
    Song 1
&amp;ldquo;`
&lt;strong&gt;Note:&lt;/strong&gt; this take aways here are that understanding when to use inheritance and understanding when composition is needed. Inheritance is not meant for sharing of methods, it is meant for specialization of them.&lt;/p&gt;

&lt;p&gt;Until Next Time.&lt;/p&gt;

&lt;p&gt;Z&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Duck Typing</title>
    <link rel="alternate" href="http://blog.url.com/2015/09/14/duck_typing/"/>
    <id>http://blog.url.com/2015/09/14/duck_typing/</id>
    <published>2015-09-13T23:15:00-07:00</published>
    <updated>2015-09-13T23:15:40-07:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h3&gt;Question:&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Is explicit class checking ever absolutely necessary? Are their situations in which even if other options are available, checking the class of an object is still the best thing to do?&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Response&lt;/h3&gt;

&lt;p&gt;Explicitly checking the class of an object is not always necessary. It majorly depends on what the class is being used for and what possible objects will be passed in. The is no point creating verbose code that checks many cases unless they need to be handled separately.&lt;/p&gt;

&lt;h5&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;class Media
    def initialize(file)
        return file.listen if file.respond_to?(:listen)
        return file.watch if file.respond_to?(:watch)
        return file.view if file.respond_to?(:view)
        raise StandardError
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here you can check the class of an object responds to a certain method. This can test all the considered cases and raises an exception for the rest. Thus checking the class of some but not all.&lt;/p&gt;

&lt;h3&gt;Question:&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Name something weird that can happen when you write your contracts on the messages your objects respond to rather than what class of object they are.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Response&lt;/h3&gt;

&lt;p&gt;The object could response &lt;code&gt;false&lt;/code&gt; to a &lt;code&gt;response_to(:read)&lt;/code&gt; method but can still run perfectly when called &lt;code&gt;objet.read --&amp;gt; &amp;quot;hello&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;Questions&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Try to identify some feature of Ruby that relies on duck typing either for its basic functionality or as an extension point meant to be customized by application programmers.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class BoomBox
    def play(media)
        media.play
    end
end

class CD
    def play
    end
end

class Radio
    def play
    end
end

## IRB

BoomBox.play(CD.new)
BoomBox.play(Radio.new)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Question&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Share a bit of code which does explicit class comparison that you think would be very difficult to convert to a duck-typing style.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Example&lt;/h3&gt;

&lt;p&gt;In our example above it would be less useful to use duck typing if we also had other classes that could respond to play but we didn&amp;rsquo;t want it to be passed into the BoomBox. Essentially it doesn&amp;rsquo;t restrict enough and to get around it we sometimes use verbose rescue statements for each case.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## i.e
class Child
    def play
        self.swim
    end
end
BoomBox.play(Child.new)
    ## --&amp;gt; Error -- Electrocution
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Question&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Share a bit of code (either your own or from a OSS project you like) that you feel uses duck typing effectively.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class GenericOrder
  def create(order)
    order.create
  end
end

class WholeLoan
  def create
    puts &amp;#39;Creating WL Order&amp;#39;
  end
end

class FractionalLoan
  def create
    puts &amp;#39;Creating FL Order&amp;#39;
  end
end

GenerateOrder.create(WholeLoan.new)
GenerateOrder.create(FractionalLoan.new)
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>Module Mindset</title>
    <link rel="alternate" href="http://blog.url.com/2015/09/08/module-mindset/"/>
    <id>http://blog.url.com/2015/09/08/module-mindset/</id>
    <published>2015-09-08T10:01:00-07:00</published>
    <updated>2015-09-08T10:02:52-07:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h3&gt;Overview&lt;/h3&gt;

&lt;p&gt;This week I spent a couple minutes rethinking about how I conceptualize modules by reading this article. I had ery limited of modules and in practice very rarely used them. I usually just use different types of objects (Value or Service) within my code, but would like to begin to see where and when I should be using Modules.&lt;/p&gt;

&lt;p&gt;Modules perpetuate the single responsibility principal. They also allow for better reading and understanding by providing a clear namespace when they are used. They also allow classes to share common methods when setup in a class.&lt;/p&gt;

&lt;h3&gt;Learnings&lt;/h3&gt;

&lt;p&gt;Some things I found that could be useful/interesting from this article:&lt;/p&gt;

&lt;h5&gt;Different ways to impliments modules&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Include

&lt;ul&gt;
&lt;li&gt; A module can be included within a class. The objects of this class can now access all the methods of the included module. Note this adds methods to an instance of the class&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Extend

&lt;ul&gt;
&lt;li&gt;A module can be extended in a class. Unlike include this is used to add class methods.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Foo
  def foo
    puts &amp;#39;heyyyyoooo!&amp;#39;
  end
end

class Bar
  include Foo
end

Bar.new.foo # heyyyyoooo!
Bar.foo # NoMethodError: undefined method ‘foo’ for Bar:Class

class Baz
  extend Foo
end

Baz.foo # heyyyyoooo!
Baz.new.foo # NoMethodError: undefined method ‘foo’ for #&amp;lt;Baz:0x1e708&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://www.railstips.org/blog/archives/2009/05/15/include-vs-extend-in-ruby/"&gt;source&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;Spaceship Oerator (&amp;lt;=&amp;gt;)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;This operator is often used in sorting. It compares the paramters coming in and either gives a 1,0 or -1 based on the comparison. This can be useful for comparing business logic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Logic:
&lt;code&gt;
a &amp;lt;=&amp;gt; b :=
  if a &amp;lt; b then return -1
  if a = b then return  0
  if a &amp;gt; b then return  1
  if a and b are not comparable then return nil
&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;Modules as first class objects&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Instead of layering modules within classes it is also possible to use a module on its own. Thus the module takes on the role of a first class object.&lt;/li&gt;
&lt;li&gt;These objects do not depend on state so there is no need to create an instance of it.&lt;/li&gt;
&lt;li&gt;An example of this (the text uses) is a Math module.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Dialogue&lt;/h3&gt;

&lt;p&gt;After reading this article it was clear I have not been utilizing Modules as much as I should. The trick is to think and understand when is the best time to use a Module rather than a specialized object. Also which ways to impliment a Module depend entirely on the situation. Hopefully I will now begin to see and use Modules more!&lt;/p&gt;
</content>
  </entry>
</feed>
