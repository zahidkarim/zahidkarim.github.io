<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2015-09-13T23:15:00-07:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Duck Typing</title>
    <link rel="alternate" href="http://blog.url.com/2015/09/14/duck_typing/"/>
    <id>http://blog.url.com/2015/09/14/duck_typing/</id>
    <published>2015-09-13T23:15:00-07:00</published>
    <updated>2015-09-13T23:15:40-07:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h3&gt;Question:&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Is explicit class checking ever absolutely necessary? Are their situations in which even if other options are available, checking the class of an object is still the best thing to do?&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Response&lt;/h3&gt;

&lt;p&gt;Explicitly checking the class of an object is not always necessary. It majorly depends on what the class is being used for and what possible objects will be passed in. The is no point creating verbose code that checks many cases unless they need to be handled separately.&lt;/p&gt;

&lt;h5&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;class Media
    def initialize(file)
        return file.listen if file.respond_to?(:listen)
        return file.watch if file.respond_to?(:watch)
        return file.view if file.respond_to?(:view)
        raise StandardError
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here you can check the class of an object responds to a certain method. This can test all the considered cases and raises an exception for the rest. Thus checking the class of some but not all.&lt;/p&gt;

&lt;h3&gt;Question:&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Name something weird that can happen when you write your contracts on the messages your objects respond to rather than what class of object they are.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Response&lt;/h3&gt;

&lt;p&gt;The object could response &lt;code&gt;false&lt;/code&gt; to a &lt;code&gt;response_to(:read)&lt;/code&gt; method but can still run perfectly when called &lt;code&gt;objet.read --&amp;gt; &amp;quot;hello&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;Questions&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Try to identify some feature of Ruby that relies on duck typing either for its basic functionality or as an extension point meant to be customized by application programmers.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class BoomBox
    def play(media)
        media.play
    end
end

class CD
    def play
    end
end

class Radio
    def play
    end
end

## IRB

BoomBox.play(CD.new)
BoomBox.play(Radio.new)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Question&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Share a bit of code which does explicit class comparison that you think would be very difficult to convert to a duck-typing style.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Example&lt;/h3&gt;

&lt;p&gt;In our example above it would be less useful to use duck typing if we also had other classes that could respond to play but we didn&amp;rsquo;t want it to be passed into the BoomBox. Essentially it doesn&amp;rsquo;t restrict enough and to get around it we sometimes use verbose rescue statements for each case.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## i.e
class Child
    def play
        self.swim
    end
end
BoomBox.play(Child.new)
    ## --&amp;gt; Error -- Electrocution
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Question&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Share a bit of code (either your own or from a OSS project you like) that you feel uses duck typing effectively.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class GenericOrder
  def create(order)
    order.create
  end
end

class WholeLoan
  def create
    puts &amp;#39;Creating WL Order&amp;#39;
  end
end

class FractionalLoan
  def create
    puts &amp;#39;Creating FL Order&amp;#39;
  end
end

GenerateOrder.create(WholeLoan.new)
GenerateOrder.create(FractionalLoan.new)
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>Module Mindset</title>
    <link rel="alternate" href="http://blog.url.com/2015/09/08/module-mindset/"/>
    <id>http://blog.url.com/2015/09/08/module-mindset/</id>
    <published>2015-09-08T10:01:00-07:00</published>
    <updated>2015-09-08T10:02:52-07:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h3&gt;Overview&lt;/h3&gt;

&lt;p&gt;This week I spent a couple minutes rethinking about how I conceptualize modules by reading this article. I had ery limited of modules and in practice very rarely used them. I usually just use different types of objects (Value or Service) within my code, but would like to begin to see where and when I should be using Modules.&lt;/p&gt;

&lt;p&gt;Modules perpetuate the single responsibility principal. They also allow for better reading and understanding by providing a clear namespace when they are used. They also allow classes to share common methods when setup in a class.&lt;/p&gt;

&lt;h3&gt;Learnings&lt;/h3&gt;

&lt;p&gt;Some things I found that could be useful/interesting from this article:&lt;/p&gt;

&lt;h5&gt;Different ways to impliments modules&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Include

&lt;ul&gt;
&lt;li&gt; A module can be included within a class. The objects of this class can now access all the methods of the included module. Note this adds methods to an instance of the class&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Extend

&lt;ul&gt;
&lt;li&gt;A module can be extended in a class. Unlike include this is used to add class methods.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Foo
  def foo
    puts &amp;#39;heyyyyoooo!&amp;#39;
  end
end

class Bar
  include Foo
end

Bar.new.foo # heyyyyoooo!
Bar.foo # NoMethodError: undefined method ‘foo’ for Bar:Class

class Baz
  extend Foo
end

Baz.foo # heyyyyoooo!
Baz.new.foo # NoMethodError: undefined method ‘foo’ for #&amp;lt;Baz:0x1e708&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://www.railstips.org/blog/archives/2009/05/15/include-vs-extend-in-ruby/"&gt;source&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;Spaceship Oerator (&amp;lt;=&amp;gt;)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;This operator is often used in sorting. It compares the paramters coming in and either gives a 1,0 or -1 based on the comparison. This can be useful for comparing business logic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Logic:
&lt;code&gt;
a &amp;lt;=&amp;gt; b :=
  if a &amp;lt; b then return -1
  if a = b then return  0
  if a &amp;gt; b then return  1
  if a and b are not comparable then return nil
&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;Modules as first class objects&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Instead of layering modules within classes it is also possible to use a module on its own. Thus the module takes on the role of a first class object.&lt;/li&gt;
&lt;li&gt;These objects do not depend on state so there is no need to create an instance of it.&lt;/li&gt;
&lt;li&gt;An example of this (the text uses) is a Math module.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Dialogue&lt;/h3&gt;

&lt;p&gt;After reading this article it was clear I have not been utilizing Modules as much as I should. The trick is to think and understand when is the best time to use a Module rather than a specialized object. Also which ways to impliment a Module depend entirely on the situation. Hopefully I will now begin to see and use Modules more!&lt;/p&gt;
</content>
  </entry>
</feed>
